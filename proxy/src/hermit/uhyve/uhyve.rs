//! This file contains the entry point to the Unikernel Hypervisor. The uhyve utilizes KVM to
//! create a Virtual Machine and load the kernel.

use std::fs::{File,OpenOptions};
use std::path::Path;
use std::os::unix::fs::OpenOptionsExt;
use std::os::unix::io::AsRawFd;
use std::ptr;
use libc;

use hermit::{Isle, IsleParameterUhyve};
use super::{Error, Result, NameIOCTL};
use super::vm::VirtualMachine;

/// The normal way of defining a IOCTL interface is provided by C macros. In Rust we have our own
/// flawed macro system. The module below wraps a bunch of functions which are generated by the
/// ioctl! macro and need to be wrapped further to provide a safe interface.
pub mod ioctl {
    use hermit::uhyve::kvm_header::{KVMIO, kvm_msr_list, kvm_cpuid2, kvm_memory_region, kvm_dirty_log, kvm_memory_alias, kvm_userspace_memory_region, kvm_regs,kvm_sregs, kvm_enable_cap, kvm_mp_state};

    ioctl_write_ptr_bad!(get_version, request_code_none!(KVMIO, 0x00), u8);
    ioctl_write_int_bad!(create_vm, request_code_none!(KVMIO, 0x01));
    ioctl_readwrite!(get_msr_index_list, KVMIO, 0x02, kvm_msr_list);

    ioctl_write_ptr_bad!(get_vcpu_mmap_size, request_code_none!(KVMIO, 0x04), u8);
    ioctl_readwrite!(get_supported_cpuid, KVMIO, 0x05, kvm_cpuid2);
    ioctl_readwrite!(get_emulated_cpuid, KVMIO, 0x09, kvm_cpuid2);
    ioctl_write_ptr!(set_cpuid2, KVMIO, 0x90, kvm_cpuid2);

    ioctl_write_int_bad!(create_vcpu, request_code_none!(KVMIO, 0x41));
    ioctl_write_ptr!(get_dirty_log, KVMIO, 0x42, kvm_dirty_log);
    ioctl_write_ptr!(set_memory_alias, KVMIO, 0x43, kvm_memory_alias);
    ioctl_write_ptr_bad!(set_nr_mmu_pages, request_code_none!(KVMIO, 0x44), u8);
    ioctl_write_ptr_bad!(get_nr_mmu_pages, request_code_none!(KVMIO, 0x45), u8);
    
    ioctl_write_ptr!(set_memory_region, KVMIO, 0x40, kvm_memory_region);
    ioctl_write_ptr!(set_user_memory_region, KVMIO, 0x46, kvm_userspace_memory_region);

    ioctl_write_ptr_bad!(create_irqchip, request_code_none!(KVMIO, 0x60), u8);

    ioctl_write_ptr_bad!(run, request_code_none!(KVMIO, 0x80), u8);
    ioctl_read!(get_regs, KVMIO, 0x81, kvm_regs);
    ioctl_write_ptr!(set_regs, KVMIO, 0x82, kvm_regs);
    ioctl_read!(get_sregs, KVMIO, 0x83, kvm_sregs);
    ioctl_write_ptr!(set_sregs, KVMIO, 0x84, kvm_sregs);

    ioctl_read_bad!(check_extension, request_code_none!(KVMIO, 0x03), u8);
    ioctl_read_bad!(set_tss_addr, request_code_none!(KVMIO, 0x47), u8);
    ioctl_write_ptr!(set_identity_map_addr, KVMIO, 0x48, u64);
    ioctl_write_ptr!(enable_cap, KVMIO, 0xa3, kvm_enable_cap);

    ioctl_write_ptr!(set_mp_state, KVMIO, 0x99, kvm_mp_state);
}

/// KVM is freezed at version 12, so all others are invalid
#[derive(Debug)]
pub enum Version{
    Version12,
    Unsupported
}

/// This is the entry point of our module, it connects to the KVM device and wraps the functions
/// which accept the global file descriptor.
pub struct KVM {
    file: File
}

impl KVM {
    // Connects to the KVM hypervisor, by opening the virtual device /dev/kvm
    pub fn new() -> KVM {
        
        let kvm_file = OpenOptions::new()
            .read(true)
            .write(true)
            .custom_flags(libc::O_CLOEXEC)
            .open("/dev/kvm").unwrap();
  
        debug!("Connection to KVM is established.");
        
        KVM { file: kvm_file }
    }

    // Acquires the KVM version to seperate ancient systems
    pub fn version(&self) -> Result<Version> {
        unsafe {
            match ioctl::get_version(self.file.as_raw_fd(), ptr::null_mut()) {
                Ok(12) => Ok(Version::Version12),
                Ok(_)  => Ok(Version::Unsupported),
                Err(_) => Err(Error::IOCTL(NameIOCTL::GetVersion))
            }
        }
    }

    // Creates a new virtual machine and forwards the new fd to an object
    pub fn create_vm(&self, size: usize, num_cpus: u32) -> Result<VirtualMachine> {
        unsafe {
            match ioctl::create_vm(self.file.as_raw_fd(), 0) {
                Ok(vm_fd) => VirtualMachine::new(self.file.as_raw_fd(), vm_fd, size,num_cpus),
                Err(_) => Err(Error::IOCTL(NameIOCTL::CreateVM))
            }
        }


    }
}

pub struct Uhyve {
    kvm: KVM,
    vm: VirtualMachine,
}

impl Uhyve {
    pub fn new(path: &str, mem_size: u64, num_cpus: u32, additional: IsleParameterUhyve) -> Result<Uhyve> {
        let kvm = KVM::new();
        let mut vm = kvm.create_vm(mem_size as usize, num_cpus)?;
        vm.load_kernel(path, additional)?;
        vm.init()?;
    
        Ok(Uhyve {
            kvm: kvm,
            vm: vm,
        })
    }
}

impl Isle for Uhyve {
    fn num(&self) -> u8 {
        0
    }

    fn log_file(&self) -> Option<&Path> {
        None
    }

    fn run(&mut self) -> Result<()> {
        self.vm.run().map(|_| ())
    }

    fn stop(&mut self) -> Result<i32> {
        self.vm.stop()
    }

    fn output(&self) -> String {
        self.vm.output()
    }
}
